# 05_ex30.rb の問題解説

## 1. まず「ハッシュ」とは？

ハッシュは、**キーと値のペアを保存する入れ物**です。

### 例：
```ruby
person = {
  "name" => "太郎",
  "age" => 25,
  "email" => "taro@example.com"
}
```

これは1つのハッシュで、1人分の情報を保存しています。

- キー `"name"` の値は `"太郎"`
- キー `"age"` の値は `25`
- キー `"email"` の値は `"taro@example.com"`

---

## 2. 元のコードの問題

### 元のコードが何も表示されなかった理由

**問題：ファイルの最後に `main()` の呼び出しがない**

```ruby
def main()
  # ... コード ...
  return 0
end

# ← ここに main() がない！
```

関数を定義しただけで、実行していませんでした。

**修正：ファイルの最後に `main()` を追加**

```ruby
def main()
  # ... コード ...
  return 0
end

main()  # ← これを追加
```

---

## 3. 現在のコードの動作（もう1つの問題）

### コードが何をしているか

```ruby
def mbox_parser(file_path)
  sender_list = []  # 空の配列

  File.open(file_path, "r") do |f|
    f.each_line do |line|
      # From:, Date:, Subject: で始まる行だけ処理
      next unless target.any?{|h| line.start_with?(h)}

      cur_data = {}  # ← 毎回、新しい空のハッシュを作る
      value = line.split(':', 2)[1].strip

      if line.start_with?("From: ")
        cur_data['From'] = address
      elsif line.start_with?("Date: ")
        cur_data['Date'] = date_obj
      elsif line.start_with?("Subject: ")
        cur_data['Subject'] = decoded_sub
      end

      sender_list << cur_data  # ← ハッシュを配列に追加
    end
  end

  sender_list  # ← 配列を返す
end
```

### 実際の動作

メールファイルに以下のような内容があるとします：

```
...
Subject: こんにちは
...
Date: Wed, 8 Oct 2025 13:46:42 +0000
From: taro@example.com
...
```

**コードの処理：**

1. `Subject:` の行を見つける
   - 新しい `cur_data = {}` を作る
   - `cur_data['Subject'] = "こんにちは"` を保存
   - `sender_list` に追加 → `[{"Subject"=>"こんにちは"}]`

2. `Date:` の行を見つける
   - **また新しい** `cur_data = {}` を作る
   - `cur_data['Date'] = ...` を保存
   - `sender_list` に追加 → `[{"Subject"=>"こんにちは"}, {"Date"=>...}]`

3. `From:` の行を見つける
   - **また新しい** `cur_data = {}` を作る
   - `cur_data['From'] = "taro@example.com"` を保存
   - `sender_list` に追加 → `[{"Subject"=>"こんにちは"}, {"Date"=>...}, {"From"=>"taro@example.com"}]`

### 結果

**3つの別々のハッシュ**ができます：

```ruby
[
  {"Subject" => "こんにちは"},
  {"Date" => 2025-10-08 13:46:42 +0000},
  {"From" => "taro@example.com"}
]
```

### 出力

```
---
Subject: こんにちは
---
Date: 2025-10-08 13:46:42 +0000
---
From: taro@example.com
```

各ハッシュごとに `---` で区切られて表示されます。

---

## 4. 望ましい動作（もし1通のメールを1つにまとめたいなら）

### 理想的な結果

1つのメールの情報を**1つのハッシュ**にまとめる：

```ruby
[
  {
    "From" => "taro@example.com",
    "Date" => 2025-10-08 13:46:42 +0000,
    "Subject" => "こんにちは"
  }
]
```

### 理想的な出力

```
---
From: taro@example.com
Date: 2025-10-08 13:46:42 +0000
Subject: こんにちは
```

1つのメールが1つのブロックで表示されます。

---

## 5. まとめ

### 現在の状態

- ✅ `main()` を追加したので、コードは実行されるようになった
- ❌ しかし、各ヘッダー行（From, Date, Subject）が別々のハッシュになっている

### 現在のコードの動作

- **1つのメールが3つのハッシュに分かれて表示される**

### もし変更が必要なら

1つのメールを1つのハッシュにまとめるには、ロジックの変更が必要です。
（メールの境界を判定して、同じメールのヘッダーを1つのハッシュに集める必要があります）

---

## 6. 現在のエラー（NoMethodError）の詳細解説

### エラーメッセージ

```
undefined method `[]=' for nil:NilClass (NoMethodError)
cur_data['Subject'] = decoded_sub
```

### エラーの意味

**`cur_data` が `nil`（何もない）なのに、ハッシュとして使おうとしている**

### わかりやすい比喩

- `cur_data` は「箱」です
- `cur_data['Subject'] = "値"` は「箱の中に『Subject』というラベルを貼って、値を入れる」という意味
- しかし、**箱自体が存在しない（nil）**ので、ラベルを貼ることができない
- これがエラーの原因です

### 現在のコードの流れ

```ruby
def mbox_parser(file_path)
  sender_list = []

  File.open(file_path, "r") do |f|
    f.each_line do |line|
      # (1) メールの境界で新しい箱を作る
      if line.start_with?("From ")
        cur_data = {}  # ← ここで箱を作る
        next
      end

      next unless target.any?{|h| line.start_with?(h)}
      value = line.split(':', 2)[1].strip

      # (2) ヘッダー行を処理して箱に入れる
      if line.start_with?("From: ")
        cur_data['From'] = address  # ← 箱を使う
      elsif line.start_with?("Date: ")
        cur_data['Date'] = date_obj  # ← 箱を使う
      elsif line.start_with?("Subject: ")
        cur_data['Subject'] = decoded_sub  # ← 箱を使う（エラー！）
      end

      sender_list << cur_data
    end
  end

  sender_list
end
```

### なぜエラーが起きるか

**mboxファイルの実際の構造：**

```
From 1845421622024689376@xxx Wed Oct 08 13:46:43 +0000 2025  ← (1) メールの境界
X-GM-THRID: 1845421622024689376
X-Gmail-Labels: ...
...（たくさんのヘッダー）...
Subject: こんにちは                                          ← (2) ここで cur_data['Subject'] を使う
Date: Wed, 8 Oct 2025 13:46:42 +0000                         ← (3) ここで cur_data['Date'] を使う
From: WordPress <wordpress@digitalgeek.tech>                 ← (4) ここで cur_data['From'] を使う
...（メール本文）...

From 1845049100724090422@xxx Sat Oct 04 11:05:39 +0000 2025  ← 次のメールの境界
...
```

**コードの動作：**

1. 1行目：`From ` で始まる → `cur_data = {}` が作られる ✅
2. 2〜数十行：その他のヘッダー（`X-GM-THRID`, `X-Gmail-Labels` など）→ スキップされる
3. `Subject:` の行 → `cur_data['Subject'] = ...` を実行 ✅ (OK)
4. `Date:` の行 → `cur_data['Date'] = ...` を実行 ✅ (OK)
5. `From:` の行 → `cur_data['From'] = ...` を実行 ✅ (OK)

**しかし、もしファイルの最初の行が `From ` で始まらない場合：**

```
Subject: こんにちは  ← (1) 最初の行がこれだと...
Date: ...
From: ...
```

1. `Subject:` の行 → `cur_data['Subject'] = ...` を実行しようとする
2. しかし、まだ `cur_data = {}` が実行されていない
3. `cur_data` は存在しない（nil）
4. **エラー！**

---

## 7. 正しい設計方法（メールごとにハッシュを分離する）

### mboxファイルの構造を理解する

```
From メール1の情報（境界）  ← メール1の開始
Subject: メール1の件名
Date: メール1の日付
From: メール1の送信者
（メール1の本文）

From メール2の情報（境界）  ← メール2の開始（メール1の終了）
Subject: メール2の件名
Date: メール2の日付
From: メール2の送信者
（メール2の本文）

From メール3の情報（境界）  ← メール3の開始（メール2の終了）
...
```

**重要なポイント：**
- **`From ` で始まる行が「メールの境界」**
- 1つのメールの中に、`Subject:`, `Date:`, `From:` などのヘッダーが複数ある
- これらを**1つのハッシュにまとめる**必要がある

### 正しいロジック

```ruby
def mbox_parser(file_path)
  target = ["From: ", "Date: ", "Subject: "]
  sender_list = []
  cur_data = nil  # ← 最初は nil

  File.open(file_path, "r") do |f|
    f.each_line do |line|
      # (1) メールの境界を検出
      if line.start_with?("From ")
        # 前のメールがあれば、sender_list に追加
        if cur_data && !cur_data.empty?
          sender_list << cur_data
        end

        # 新しいメールのために新しいハッシュを作る
        cur_data = {}
        next
      end

      # (2) cur_data が nil なら何もしない（まだメールが始まっていない）
      next if cur_data.nil?

      # (3) ヘッダー行を処理
      next unless target.any?{|h| line.start_with?(h)}
      value = line.split(':', 2)[1].strip

      if line.start_with?("From: ")
        address = parse_from(value)
        cur_data['From'] = address ? address : "unknown"
      elsif line.start_with?("Date: ")
        date_obj = Time.parse(value)
        cur_data['Date'] = date_obj
      elsif line.start_with?("Subject: ")
        decoded_sub = NKF.nkf("-w", value)
        cur_data['Subject'] = decoded_sub
      end
    end
  end

  # (4) 最後のメールを追加
  if cur_data && !cur_data.empty?
    sender_list << cur_data
  end

  sender_list
end
```

### このコードの動作の流れ（図解）

#### ファイルを1行ずつ読む

```
行1: From 1845421622024689376@xxx ...
     → 新しいハッシュを作る: cur_data = {}
     → 前のメールはない（nilだから）ので何もしない

行2-50: X-GM-THRID: ..., X-Gmail-Labels: ..., など
     → target に含まれないのでスキップ

行51: Subject: こんにちは
     → cur_data['Subject'] = "こんにちは"
     → cur_data = {"Subject" => "こんにちは"}

行52-60: その他のヘッダー
     → スキップ

行61: Date: Wed, 8 Oct 2025 13:46:42 +0000
     → cur_data['Date'] = 2025-10-08 13:46:42 +0000
     → cur_data = {"Subject" => "こんにちは", "Date" => 2025-10-08 13:46:42 +0000}

行62: From: WordPress <wordpress@digitalgeek.tech>
     → cur_data['From'] = "wordpress@digitalgeek.tech"
     → cur_data = {
          "Subject" => "こんにちは",
          "Date" => 2025-10-08 13:46:42 +0000,
          "From" => "wordpress@digitalgeek.tech"
        }

行63-100: メール本文
     → スキップ

行101: From 1845049100724090422@xxx ...  ← 次のメールの境界！
     → 前のメール（cur_data）を sender_list に追加
     → sender_list = [
          {
            "Subject" => "こんにちは",
            "Date" => 2025-10-08 13:46:42 +0000,
            "From" => "wordpress@digitalgeek.tech"
          }
        ]
     → 新しいハッシュを作る: cur_data = {}

行102-150: 2通目のメールのヘッダーと本文
     → 同様の処理...

ファイルの終わり:
     → 最後のメール（cur_data）を sender_list に追加
```

### 結果

```ruby
sender_list = [
  {
    "From" => "wordpress@digitalgeek.tech",
    "Date" => 2025-10-08 13:46:42 +0000,
    "Subject" => "こんにちは"
  },
  {
    "From" => "payments-noreply@google.com",
    "Date" => 2025-10-04 04:05:39 -0700,
    "Subject" => "Google Workspace: ..."
  },
  ...
]
```

### 出力

```
---
From: wordpress@digitalgeek.tech
Date: 2025-10-08 13:46:42 +0000
Subject: こんにちは
---
From: payments-noreply@google.com
Date: 2025-10-04 04:05:39 -0700
Subject: Google Workspace: ...
---
...
```

**1つのメールが1つのブロックで表示されます！**

---

## 8. 重要なポイントまとめ

### エラーの原因

1. `cur_data` が初期化されていない（nil）のに使おうとした
2. 各ヘッダー行で `sender_list << cur_data` を実行していた

### 正しい設計のポイント

1. **メールの境界（`From `）を検出する**
2. **境界に到達したら、前のメールを保存する**
3. **新しいハッシュを作る**
4. **ヘッダー行で、同じハッシュに値を追加していく**
5. **ファイルの終わりで、最後のメールを保存する**

### キーとなるチェック

```ruby
# cur_data が nil でないかチェック
next if cur_data.nil?

# メールの境界で、前のメールを保存
if cur_data && !cur_data.empty?
  sender_list << cur_data
end

# ファイルの終わりで、最後のメールを保存
if cur_data && !cur_data.empty?
  sender_list << cur_data
end
```
